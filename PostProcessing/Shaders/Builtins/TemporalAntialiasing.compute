
#pragma exclude_renderers gles gles3 d3d11_9x
#pragma enable_d3d11_debug_symbols

#include "../StdLib.hlsl"
#include "../Colors.hlsl"

#include "TemporalAntialiasing.hlsl"

SamplerState sampler_LinearClamp;

TEXTURE2D_SAMPLER2D(_MainTex, sampler_MainTex);
float4 _MainTex_TexelSize;

TEXTURE2D_SAMPLER2D(_HistoryTex, sampler_HistoryTex);

RWTexture2D<float4> _DestinationTex;
RWTexture2D<float4> _OutputHistoryTex;

TEXTURE2D_SAMPLER2D(_CameraDepthTexture, sampler_CameraDepthTexture);
float4 _CameraDepthTexture_TexelSize;

TEXTURE2D_SAMPLER2D(_CameraMotionVectorsTexture, sampler_CameraMotionVectorsTexture);

float2 _Jitter;
float4 _FinalBlendParameters; // x: static, y: dynamic, z: motion amplification
float _Sharpness;

float _SampleWeights[9];
float _PlusWeights[5];

float2 GetClosestFragment(float2 uv)
{
    const float2 k = _CameraDepthTexture_TexelSize.xy;

    const float4 neighborhood = float4(
        
        SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_CameraDepthTexture, UnityStereoClamp(uv - k), 0),
        SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_CameraDepthTexture, UnityStereoClamp(uv + float2(k.x, -k.y)), 0),
        SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_CameraDepthTexture, UnityStereoClamp(uv + float2(-k.x, k.y)), 0),
        SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_CameraDepthTexture, UnityStereoClamp(uv + k), 0)
    );

#if defined(UNITY_REVERSED_Z)
    #define COMPARE_DEPTH(a, b) step(b, a)
#else
    #define COMPARE_DEPTH(a, b) step(a, b)
#endif

    float3 result = float3(0.0, 0.0, SAMPLE_DEPTH_TEXTURE_LOD(_CameraDepthTexture, sampler_CameraDepthTexture, uv, 0));
    result = lerp(result, float3(-1.0, -1.0, neighborhood.x), COMPARE_DEPTH(neighborhood.x, result.z));
    result = lerp(result, float3( 1.0, -1.0, neighborhood.y), COMPARE_DEPTH(neighborhood.y, result.z));
    result = lerp(result, float3(-1.0,  1.0, neighborhood.z), COMPARE_DEPTH(neighborhood.z, result.z));
    result = lerp(result, float3( 1.0,  1.0, neighborhood.w), COMPARE_DEPTH(neighborhood.w, result.z));

    return (uv + result.xy * k);
}

float4 ClipToAABB(float4 color, float3 minimum, float3 maximum)
{
    // Note: only clips towards aabb center (but fast!)
    float3 center = 0.5 * (maximum + minimum);
    float3 extents = 0.5 * (maximum - minimum);

    // This is actually `distance`, however the keyword is reserved
    float3 offset = color.rgb - center;

    float3 ts = abs(extents / (offset + 0.0001));
    float t = saturate(Min3(ts.x, ts.y, ts.z));
    color.rgb = center + offset * t;
    return color;
}

struct OutputSolver
{
    float4 destination;
    float4 history;
};

OutputSolver Solve(float2 motion, float2 texcoord, uint2 id)
{
    const float2 k = _MainTex_TexelSize.xy;
    float2 uv = UnityStereoClamp(texcoord - _Jitter);

    float4 color = SAMPLE_TEXTURE2D_LOD(_MainTex, sampler_MainTex, uv, 0);

    float4 topLeft = SAMPLE_TEXTURE2D_LOD(_MainTex, sampler_MainTex, UnityStereoClamp(uv - k * 0.5), 0);
    float4 bottomRight = SAMPLE_TEXTURE2D_LOD(_MainTex, sampler_MainTex, UnityStereoClamp(uv + k * 0.5), 0);

    float4 corners = 4.0 * (topLeft + bottomRight) - 2.0 * color;

    // Sharpen output
    color += (color - (corners * 0.166667)) * 2.718282 * _Sharpness;
    color = clamp(color, 0.0, HALF_MAX_MINUS1);

    // Tonemap color and history samples
    float4 average = (corners + color) * 0.142857;

    float4 history = SAMPLE_TEXTURE2D_LOD(_HistoryTex, sampler_HistoryTex, UnityStereoClamp(texcoord - motion), 0);

    float motionLength = length(motion);
    float2 luma = float2(Luminance(average), Luminance(color));
    //float nudge = 4.0 * abs(luma.x - luma.y);
    float nudge = lerp(4.0, 0.25, saturate(motionLength * 100.0)) * abs(luma.x - luma.y);

    float4 minimum = min(bottomRight, topLeft) - nudge;
    float4 maximum = max(topLeft, bottomRight) + nudge;

    // Clip history samples
    history = ClipToAABB(history, minimum.xyz, maximum.xyz);

    // Blend method
    float weight = clamp(
        lerp(_FinalBlendParameters.x, _FinalBlendParameters.y, motionLength * _FinalBlendParameters.z),
        _FinalBlendParameters.y, _FinalBlendParameters.x
    );

    color = lerp(color, history, weight);
    color = clamp(color, 0.0, HALF_MAX_MINUS1);

    OutputSolver output;
    output.destination = color;
    output.history = color;
    return output;
}

#pragma kernel SolverDilate         SOLVER=SolverDilate         DILATE=1
#pragma kernel SolverDilateStereo   SOLVER=SolverDilateStereo   DILATE=1
#pragma kernel SolverNoDilate       SOLVER=SolverNoDilate       DILATE=0

[numthreads(8, 8, 1)]
void SOLVER(uint2 id : SV_DispatchThreadID)
{
    float2 coord = float2(id) + 0.5;
    float2 texcoord = coord * _MainTex_TexelSize.xy;
    float2 texcoordStereo = TransformStereoScreenSpaceTex(texcoord, 1.0);

#if DILATE
    float2 closest = GetClosestFragment(texcoordStereo);
#else
    float2 closest = texcoordStereo;
#endif

    float2 motion = SAMPLE_TEXTURE2D_LOD(_CameraMotionVectorsTexture, sampler_CameraMotionVectorsTexture, closest, 0).xy;
    OutputSolver solver = Solve(motion, texcoordStereo, id);

    _DestinationTex[id] = solver.destination;
    _OutputHistoryTex[id] = solver.history;
}